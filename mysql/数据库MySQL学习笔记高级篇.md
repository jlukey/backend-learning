# 1. mysql架构介绍

## 1.1 mysql简介

MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于Oracle公司。

MySQL是一种关联数据库管理系统，将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。

MySQL是开源的，所以你不需要支付额外的费用。

MySQL支持大型的数据库。可以处理拥有上千万条记录的大型数据库。MySQL使用标准的SQL数据语言形式。

MySQL可以允许于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Per、PHP、Eifel、Ruby和Tcl等。Mysql对PHP有很好的支持，PHP是目前最流行的Web开发语言。

MySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持4GB，64位系统支持最大的表文件为8TB。Mysql是可以定制的，采用了GPL协议，你可以修改源码来开发自己的MySQL系统。

> 完整的my[sql优化](https://so.csdn.net/so/search?q=sql优化&spm=1001.2101.3001.7020)需要很深的功底，大公司甚至有专门的DBA负责。
>
> - mysql内核
> - sql优化工程师
> - mysql服务器的优化
> - 各种参数常量设定
> - 查询语句优化
> - 主从复制
> - 软硬件升级
> - 容灾备份
> - sql编程

## 1.2 mysql逻辑架构介绍

和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，**插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。**这种架构可以根据业务的需求和时机需要选择合适的存储引擎。

![image-20240927175047947](https://cdn.jsdelivr.net/gh/jlukey/image@main/img/image-20240927175047947.png)

从上到下，网络连接层，数据库服务层，存储引擎层，系统文件层。

**网络连接层**

最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于tcpp的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。

**数据库服务层**

第二层架构主要完成大多少的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。在该层，服务器会解析査询并创建相应的内部解析树，并对其完成相应的优化如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。

**存储引擎层**

存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。后面介绍MyISAM和InnoDB。

**系统文件层**

系统文件层主要包括MySQL中存储数据的底层文件，将数据存储在运行于裸设备的文件系统之上，与上层的存储引擎进行交互。其存储的文件主要有：日志文件、数据文件、配置文件、MySQL进程pid文件和socket文件等。

**mysql的执行过程大概如下图：**

![image-20240927175703803](https://cdn.jsdelivr.net/gh/jlukey/image@main/img/image-20240927175703803.png)

客户端先发送查询语句给服务器，进行sql解析，生成解析树，再预处理，生成第二个解析树，最后经过优化器，生成真正的执行计划根据执行计划，调用存储引擎的API来执行查询将结果返回给客户端。

## 1.3 mysql存储引擎

看你的mysql现在已提供什么存储引擎：`show engines;`
看你的mysql当前默认的存储引擎：`show variables like ‘%storage_engine%’;`

**MyISAM vs InnoDB**

![img](https://i-blog.csdnimg.cn/blog_migrate/7ef21d3c2bcefd7b72e6584dba05f3fd.png#pic_center)

<br/>

阿里巴巴、淘宝用哪个?![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/26733f6115bd6d81452c02331dfc3c62.png#pic_center)

> InnoDB是⼀个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。⽽真正处理数据的过程是发⽣在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写⼊或修改请求的话，还需要把内存中的内容刷新到磁盘上。⽽我们知道读写磁盘的速度⾮常慢，和内存读写差了⼏个数量级，所以当我们想从表中获取某些记录时，InnoDB采取的⽅式是：将数据划分为若⼲个”⻚“，以⻚作为磁盘和内存之间交互的基本单位，InnoDB中⻚的⼤⼩⼀般为 16K,也就是在⼀般情况下，⼀次最少从磁盘中读取16KB的内容到内存中，⼀次最少把内存中的16KB内容刷新到磁盘中。
>



## 1.4 SQL 的 7 种 Join 查询

![](https://cdn.jsdelivr.net/gh/jlukey/image@main/img/img1.png)

## 1.5 mysql加载顺序

mysql执行顺序，是先从from开始读:

```sql
FROM <left_table>
ON <join_condition>
<join_type> JOIN <right_table>
WHERE <where_condition>
GROUP BY <group_by_list>
HAVING <having_condition>
SELECT 
DISTINCT <select_list>
ORDER BY <order_by_condition>
LIMIT <limit_number>
```

![image-20240926200542067](https://cdn.jsdelivr.net/gh/jlukey/image@main/img/image-20240926200542067.png)

> **笛卡尔乘积（笛卡尔积）**
>
> 例如，A={a,b}, B={0,1,2}，则：
>
> A×B={(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}
>
> B×A={(0, a), (0, b), (1, a), (1, b), (2, a), (2, b)}

# 2. mysql索引

## 2.1 索引简介

Mysql官方定义：索引（index）是帮助mysql高效获取数据的数据结构。

索引的目的在于提高查询效率，可以类比字典。如果要查 “mysql” 这个单词，我们肯定需要定位到字母 m，然后从下往下找到字母 y ，再找到剩下的字母s、q、l。如果没有索引，那么你可能需要a…z挨个找，如果我想找到Java开头的单词呢?或者Oracle开头的单词呢? 是不是觉得如果没有索引，这个事情根本无法完成?

>  **索引本质:  索引是数据结构， 排好序的快速查找数据结构。**

**数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引**。下图就是一种可能得索引方式示例：

![image-20240926201715924](https://cdn.jsdelivr.net/gh/jlukey/image@main/img/image-20240926201715924.png)

左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址。

为了加快 Col2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找法在一定的复杂度内获取到相应数据，从而快速检索出符合条件的记录。

一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。

我们平常所说的索引，如果没有特别指明，都是指B树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引、次要索引、覆盖索引、复合索引、前缀索引、唯一索引默认的都是使用 `B+` 树索引，统称索引。当然，除了 `B+` 树这种类型的索引之外，还有哈希索引（ `hash index` ）等。



## 2.2 索引的优势和劣势

**索引的优势**

* 类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本。
* 索引能极大的减少存储引擎需要扫描的数据量。
* 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。

 **索引的劣势**

* 实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的。
* 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。
* 索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或者优化查询。

## 2.3 索引分类

* **单值索引：**一个索引只包含单个列，一张表可以有多个单值索引。（建议一张表索引不要超过5个 优先考虑复合索引）
* **唯一索引：**索引列的值必须唯一，但允许有空值。
* **复合索引：**一个索引包含多个列。



## 2.4 添加索引方式

有四种方式来添加数据表的索引:

```sql
ALTER TABLE tbl_name ADD PRIMARY KEY(column_list). -- 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL.

ALTER TABLE tbl_name ADD UNIQUE index_name (column_list). -- 这条语句创建索引的值必须是唯一的(除了NULL外，NULL可能会出现多次)

ALTER TABLE tbl_name ADD INDEX index_name (column_list). -- 添加普通索引，索引值可出现多次。

ALTER TABLE tbl_name ADD FULLTEXT index_name(column_list). -- 该语句指定了索引为FULLTEXT，用于全文索引。
```



## 2.5 Mysql索引结构

mysql 选用 `B+Tree` 作为索引结构。

为什么索引能提升数据库查询效率呢？根本原因就在于**索引减少了查询过程中的IO次数**。那么它是如何做到的呢？使用B+树。下面先简单了解一下B树和B+树。

B树简略示意图：

![image-20240930102105287](https://cdn.jsdelivr.net/gh/jlukey/image@main/img/image-20240930102105287.png)

观察上图可见B树的两个特点：

1. 树内的每个节点都存储数据。
2. 叶子节点之间无指针连接。

B+树简略示意图：

![image-20240930102120319](https://cdn.jsdelivr.net/gh/jlukey/image@main/img/image-20240930102120319.png)

再看B+树相对于B树的两个特点：

1. 数据只出现在叶子节点
2. 所有叶子节点增加了一个链指针

> 叶子结点是离散数学中的概念。一棵树当中没有子结点（即度为0）的结点称为叶子结点，简称“叶子”。 叶子是指出度为0的结点，又称为终端结点。



**但是，Mysql为什么选择B+树而不是B树呢**？原因有两点：

* B树每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点能存储的key的数量很小，要保存同样多的key，就需要增加树的高度。树的高度每增加一层，查询时的磁盘I/O次数就增加一次，进而影响查询效率。而在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+树的高度。
* B+树的叶子节点上有指针进行相连，因此在做数据遍历的时候，只需要对叶子节点进行遍历即可，这个特性使得B+树非常适合做范围查询。



## 2.6 聚簇索引

**聚集索引也称聚簇索引**，这种索引中，数据库表行中数据的物理顺序与键值的逻辑（索引）顺序相同。一个表的物理顺序只有一种情况，因此对应的聚集索引只能有一个。如果某索引不是聚集索引，则表中的行物理顺序与索引顺序不匹配，与非聚集索引相比，聚集索引有着更快的检索速度。 

1. 在`Innodb`中，聚簇索引默认就是主键索引。
2. 如果表中没有定义主键，那么该表的第一个唯一非空索引被作为聚集索引。
3. 如果没有主键也没有合适的唯一索引，那么innodb内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个6个字节的列，改列的值会随着数据的插入自增。

> 扩展 1：`InnoDB`引擎是将根节点常驻内存的.
>
> 扩展 2：自增主键和uuid作为主键的区别 ?
>
> 由于主键使用了聚集索引，如果主键是自增id，那么对应的数据一定也是相邻地存放在磁盘上的，写入性能比较高。如果是uuid的形式，频繁的插入会使innodb频繁地移动磁盘块，写入性能就比较低了。



## 2.7 二级索引

聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该咋办呢？难道只能从头到尾沿着链表依次遍历记录么？

不，我们可以多建几棵B+树，不同的B+树中的数据采用不同的排序规则.

![image-20240930115601365](https://cdn.jsdelivr.net/gh/jlukey/image@main/img/image-20240930115601365.png)

如上图，多加一个以 name 字段建立的索引，就会多生成一颗非聚簇索引树。非聚集索引叶子节点上不再是真实数据，而是存储了索引字段自身值和主键索引。因此，当我们执行以下SQL语句时：

```sql
SELECT id,name FROM student WHERE name='叶良辰';
```

整个查询过程与聚集索引的过程一样，只需要扫描一次索引树（n次磁盘I/O和内存查询），即可拿到想要的数据。

但是，如果查询`name`索引树没有的数据时，情况就不一样了：

```sql
SELECT score FROM student WHERE name='叶良辰';
```

![image-20240930115809246](https://cdn.jsdelivr.net/gh/jlukey/image@main/img/image-20240930115809246.png)

注意看上图中的红色箭头，因为扫描完`name`索引后，Mysql只能获取到对应的`id`和`name`，然后用id的值再去聚集索引中去查询`score`的值。这个过程相对于聚集索引查询的效率下降，可以理解了吧。

> 这就是通常所说的回表或者二次查询：使用聚集索引查询可以直接定位到记录，而普通索引通常需要扫描两遍索引树，即先通过普通索引定位到主键值，在通过聚集索引定位到行记录，这就是所谓的回表查询，它的性能比扫描一遍索引树低。

既然普通索引会导致回表二次查询，那么有什么办法可以应对呢？**建立联合索引**。



## 2.8 联合索引

联合索引，也称多列索引，就是同时为多个列建立索引，这个概念是跟单列索引相对的。联合索引依然是B+树，但联合索引的健值数量不是一个，而是多个。构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。

例如在a和b字段上建立联合索引，索引结构将如下图所示：

![image-20240930115955587](https://cdn.jsdelivr.net/gh/jlukey/image@main/img/image-20240930115955587.png)

一目了然，当我们再执行 `SELECT score FROM student WHERE name='叶良辰'; ` 时，可以直接通过扫描非聚集索引直接获取score的值，而不再需要到聚集索引上二次扫描了。



## 2.9 最左前缀匹配

联合索引中有一个重要的课题，就是最左前缀匹配。

**最左前缀匹配原则**：在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。

这是为什么呢？我们再仔细观察索引结构，可以看到索引key在排序上，首先按a排序，a相等的节点中，再按b排序。因此，如果查询条件是a或a和b联查时，是可以应用到索引的。如果查询条件是单独使用b，因为无法确定a的值，因此无法使用索引。



假如在table表的a,b,c三个列上建立联合索引，简要分类分析下联合索引的最左前缀匹配。

首先看等值查询：

1、全值匹配查询时（where子句搜索条件顺序调换不影响索引使用，因为查询优化器会自动优化查询顺序 ），可以用到联合索引

```sql
SELECT * FROM table WHERE a=1 AND b=3 AND c=2
SELECT * FROM table WHERE b=3 AND c=4 AND a=2
```

2、匹配左边的列时，可以用到联合索引

```sql
SELECT * FROM table WHERE a=1
SELECT * FROM table WHERE a=1 AND b=3
```

3、从最左列开始时，无法用到联合索引

```sql
SELECT * FROM table WHERE b=1 AND b=3
```

4、查询列不连续时，无法使用联合索引（会用到a列索引，但c排序依赖于b，所以会先通过a列的索引筛选出a=1的记录，再在这些记录中遍历筛选c=3的值，是一种不完全使用索引的情况）

```sql
SELECT * FROM table WHERE a=1 AND c=3
```

再看范围查询：

1、范围查询最左列，可以使用联合索引

```sql
SELECT * FROM table WHERE a>1 AND a<5;
```

2、精确匹配最左列并范围匹配其右一列（a值确定时，b是有序的，因此可以使用联合索引）

```sql
SELECT * FROM table WHERE a=1 AND b>3;
```

3、精确匹配最左列并范围匹配非右一列（a值确定时，c排序依赖b，因此无法使用联合索引，但会使用a列索引筛选出a>2的记录行，再在这些行中条件 c >3逐条过滤）

```sql
SELECT * FROM table WHERE a>2 AND c>5;
```





## 2.10 InnoDB的B+索引注意事项

B+树的形成过程：

1. 每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个根节点页面。最开始表中没有数据的时候，每个B+树索引对应的根节点中既没有用户记录，也没有目录项记录。
2. 随后向表中插入用户记录时，先把用户记录存储到这个根节点中。
3. 当根节点中的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如页a中，然后对这个新页进行页分裂的操作，得到另一个新页，比如页b。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到页a或者页b中，而根节点便升级为存储目录项记录的页。

> 个过程需要大家特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是InnoDB存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。

## 2.11 总结

我们来简单做下总结：

* 每个索引都对应一棵B+树，B+树分为好多层，最末级是叶子节点，其余的是内节点。所有用户记录都存储在B+树的叶子节点，所有目录项记录都存储在内节点。

* InnoDB存储引擎会自动为主键（如果没有它会自动帮我们添加）建立聚簇索引，聚簇索引的叶子节点包含完整的用户记录。

* 我们可以为自己感兴趣的列建立二级索引，二级索引的叶子节点包含的用户记录由索引列 + 主键组成，所以如果想通过二级索引来查找完整的用户记录的话，需要通过回表操作，也就是在通过二级索引找到主键值之后再到聚簇索引中查找完整的用户记录。

* B+树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是联合索引的话，则页面和记录先按照联合索引前边的列排序，如果该列值相同，再按照联合索引后边的列排序。

* 通过索引查找记录是从B+树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了Page Directory（页目录），所以在这些页面中的查找非常快。

* MyISAM会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是主键值 + 行号的组合。在InnoDB存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在MyISAM中却需要进行一次回表操作，意味着MyISAM中建立的索引相当于全部都是二级索引。

* InnoDB的B+树中的内节点中目录项记录唯一；

* 一个数据页最少存储2条记录。
* InnoDB中的索引即数据，数据即索引，而MyISAM中是索引是索引、数据是数据。



> **哪些情况需要创建索引**
>
> 1. 主键自动建立唯一索引 .
>
> 2. 频繁作为查询条件的字段应该创建索引 .
>
> 3. 查询中与其它表关联的字段，外键关系建立索引 .
> 4. 频繁更新的字段不适合创建索引，因为每次更新不单单是更新了记录，还会更新索引，加重IO负担.
> 5. where条件里用不到的字段不创建索引 .
> 6. 单键/组合索引的选择问题，who？（在高并发下倾向创建组合索引）.
> 7. 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度 .
> 8. 查询中统计或者分组字段.



>  **哪些情况不需要创建索引**
>
> 1. 表记录太少 
>
> 2. 经常增删改的表     
>
>    Why：提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。 数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。



# 3. 性能分析

## 3.1 MySQL Query Optimizer

* Mysql中有专门负责优化 `SELECT ` 语句的优化器模块，主要功能: 通过计算分析系统中收集到的统计信息，为客户端请求的Query提供他认为最优的执行计划 (他认为最优的数据检索方式，但不见得是DBA认为是最优的，这部分最耗费时间)。

* 当客户端向 MySQL 请求一条 Query，命令解析器模块完成请求分类，区别出是 `SELECT` 并转发给MYSQL
  Query Optimizer 时，MVSQL Query Optimizer 首先会对整条 Query 进行优化，处理掉一些常量表达式的预算, 直接换算成常量值。并对 Query 中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。然后分析 Queny 中的 Hint 信息(如果有)，看显示 Hint 信息是否可以完全确定该 Query 的执行计划。如果没有 Hint 或 Hint 信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据 Query 进行写相应的计算分析，然后再得出最后的执行计划。



## 3.2 MySQL常见瓶颈

* CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候。

* IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候。

* 服务器硬件的性能瓶颈：top，free，iostat和vmstat来查看系统的性能状态。



## 3.3 Explain

**Explain是什么？**

查看执行计划。使用 `EXPLAIN` 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分析你的查询语句或是表结构的性能瓶颈。

**Explain能干嘛？**

- 表的读取顺序
- 数据读取操作的操作类型
- 哪些索引可以使用
- 哪些索引被实际使用
- 表之间的应用
- 每张表有多少行被优化器查询

**Explain怎么玩？**

- Explain+SQL语句
- 执行计划包含的信息

![](https://cdn.jsdelivr.net/gh/jlukey/image@main/img/20241009203319.png)

**各字段解释**

* **id**：select 查询的序列号，包含一组数字，表示查询中执行 select 子句或操作表的顺序。

  * id相同，执行顺序由上至下。
  * id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行。
  * id相同不同，同时存在。
  * 衍生：DERIVED

* **select_type**：查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询

  1. SIMPLE：简单的select查询，查询中不包含子查询或者UNION。
  2. PRIMARY：查询中包含任何复杂的子部分，最外层查询则被标记为PRIMARY
  3. SUBQUERY：在FROM列表中包含的子查询被标记为DERIVED（衍生），MySQL会递归执行这些子查询，把结果放在临时表里。
  4. DERIVED：在FROM列表中包含的子查询被标记为DERIVED（衍生）。MySQL会递归执行这些子查询，把结果放在临时表里。
  5. UNION：若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED。
  6. UNION RESULT：从UNION表中获取结果的SELECT。

* **table**：显示这一行的数据是关于哪些表的。

* **type**：访问类型，是较为重要的一个指标，结果值从最好到最坏依次是：

  ```sql
  system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > All
  ```

  - system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，这个也可以忽略不计。
  - const：表示通过索引一次就找到了，const用于比较primary key或则unique索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL就能将该查询转换为一个常量。
  - eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。
  - ref：非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体。
  - range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。一般就是在你的where语句中出现了between、<、>、in等的查询。这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不会扫描全部索引。
  - index：Full Index Scan，index与All区别为index类型只遍历索引树。这通常比All快，因为索引文件通常比数据文件小。（也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）
  - all：Full Table Scan，将遍历全表以找到匹配的行。
  - 一般来说，得保证查询至少达到range级别，最好能达到ref。

* **possible_keys**：显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出。但不一定被查询实际使用。

* **key**：实际使用的索引。如果为 NULL，则没有使用索引。查询中若使用了覆盖索引，则该索引仅出现在 key 列表中，不会出现在 possible_keys 列表中。（覆盖索引：查询的字段与建立的复合索引的个数一一吻合）

* **key_len**：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。key_len 显示的值为索引字段的最大可能长度，并非实际使用长度，即 key_len 是根据表定义计算而得，不是通过表内检索出的。

* **ref**：显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。查询中与其它表关联的字段，外键关系建立索引。

* **rows**：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数。

* **Extra**：包含不适合在其他列中显示但十分重要的额外信息。

  * `Using filesort`：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作成为“文件排序”。
  * `Using temporary`：使用了临时表保存中间结果，MySQL 在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by 。
  * `Using index`：表示相应的select操作中使用了覆盖索引（Covering Index），避免访问了表的数据行，效率不错！如果同时出现 using where ，表明索引被用来执行索引键值的查找；如果没有同时出现 using where ，表明索引用来读取数据而非执行查找动作。
  * `Using where`：表明使用了 where 过滤。
  * `Using join buffer`：使用了连接缓存。
  * `impossible where`：where 子句的值总是 false ，不能用来获取任何元组。（查询语句中 where 的条件不可能被满足，恒为False）。
  * `select tables optimized away`：在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。
  * `distinct`：优化 distinct 操作，在找到第一匹配的元组后即停止找相同值的动作。



## 3.4 热身Case

![](https://cdn.jsdelivr.net/gh/jlukey/image@main/img/20241009205133.png)

![](https://cdn.jsdelivr.net/gh/jlukey/image@main/img/20241009205148.png)
